<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Iobench by yongkun</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Iobench</h1>
        <p>A microbenchmark for storage systems or devices such as hard disk and flash SSD.</p>

        <p class="view"><a href="https://github.com/yongkun/iobench">View the Project on GitHub <small>yongkun/iobench</small></a></p>


        <ul>
          <li><a href="https://github.com/yongkun/iobench/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/yongkun/iobench/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/yongkun/iobench">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a name="iobench" class="anchor" href="#iobench"><span class="octicon octicon-link"></span></a>iobench</h1>

<h2>
<a name="a-microbenchmark-for-storage-systems-or-devices-such-as-hard-disk-and-flash-ssd" class="anchor" href="#a-microbenchmark-for-storage-systems-or-devices-such-as-hard-disk-and-flash-ssd"><span class="octicon octicon-link"></span></a>A microbenchmark for storage systems or devices such as hard disk and flash SSD.</h2>

<p>Features:</p>

<ul>
<li>Various IO sequences including sequential/random reads/writes, and mixed IOs.</li>
<li>Multi-threading to simulate multiple outstanding IOs.</li>
<li>Synchronous IO by O_SYNC and O_DIRECT to bypass OS or file system buffers.</li>
<li>Automatically generate figures for latency, throughput and IOPS.</li>
</ul><p>Check the help to get more information.</p>

<h2>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting started</h2>

<p>Just type 
<code>make</code> or <code>./compile.sh</code> to build it, then run <code>./iobench</code>, it will print messages about read and write latency of your current disk.</p>

<p>It is tested on Linux and Mac OS X.</p>

<p>Note that it is not recommended to use this tool on Mac OS X, because <code>O_DIRECT</code> and <code>lseek64</code> is not available on OS X. You may end up benchmarking the disk cache. It's only for development and test purpose.</p>

<p>For more details, please see the help page.</p>

<pre><code>$ ./iobench -h

NAME
       iobench - microbenchmark for storage devices/systems

SYNOPSIS
       iobench  [ -d time ] [ -f filename ] [ -n count ] [ -H ]
                [ -p size ] [ -o filename ] [ -P ] [ -r percent ]
                [ -R time ] [ -s addr ] [ -S addr ] [ -t count ]
                [ -w percent ]
       iobench  -h

DESCRIPTION
       iobench is a microbenchmark for storage systems or devices
       such as hard disk and flash SSD. It provides the following
       features:
           - Synchronous IO by O_SYNC and O_DIRECT to try to bypass
             OS or file system buffer.
           - Multi-threading to simulate multiple outstanding IOs.
           - Various IO sequences including sequential/random
             reads/writes, and mixed IOs with any R/W ratio.
       It is recommended to tune your devices/systems for prefetching
       or write-back cache with some tools like hdparm.

OPTIONS
   -d &lt;time&gt;       Duration of test of each thread in seconds. 
                   The longer the better, especially for SSDs.

   -f &lt;filename&gt;   Filename for test. Can be device file like /dev/sda.
                   This is a recommended way to test new drives.
                   Make sure you have correct permissions.
                   WARNING! All data include partition table will be
                   overwritten! Cannot be recovered!

   -n &lt;count&gt;      Send &lt;number&gt; of requests per thread. Program will
                   terminate by -n or -d which happens first.

   -H              Human friendly output.

   -o &lt;filename&gt;   Output file to append. Default output to console.

   -p &lt;size&gt;       Page size in sector (512B) for IO. This number
                   is multiplied by 512. For example, -p 8 uses 4096
                   as page size.

   -P              Output the execution details of each request.

   -r              Use random addresses. Random IO.

   -R &lt;time&gt;       Rampup interval in seconds between threads.

   -s &lt;addr&gt;       Initial file offset. Automatically aligned by 512.
                   Default to 0.

   -S &lt;addr&gt;       End offset. Automatically aligned by 512. Note
                   that lseek64 is not defined on OSX, so the largest
                   offset on Mac may be 2G even you specify larger
                   value.
                   If this value is larger than file length, reads
                   or writes may happen on the hole of the file. Run
                   'man lseek' to see the details. A safe way is to 
                   generate the file in advance using this tool or
                   dd, then set the end offset smaller than the file
                   length.
                   For sequential read/write, file offset will be
                   reset to initial address (-s) when file offset
                   reaches this value.
                   Within the valid address space, set this value the
                   larger the better, which ensures large disk head
                   movement in random access for hard disk, and might
                   trigger more data movements and block erasures
                   inside SSDs (it is highly depends on the
                   implementation of FTL).
                   Set this value to the capacity of disk when testing
                   with device file.

   -t &lt;count&gt;      Number of threads.

   -w &lt;percent&gt;    Percent of write requests. 0-100. Default 50.

</code></pre>

<p>There are some scripts to help you plot the figures with gnuplot. Gnuplot script is generated in output directory with data, can be easily customized to different figures.</p>

<p><code>./plot_figures.sh</code> will run <code>iobench</code> and plot the basic performance results into figures with throughput or IOPS.</p>

<p><img src="https://raw.githubusercontent.com/yongkun/iobench/master/sample/iobench-seq-thrpt-480.png" alt="sample/iobench-seq-thrpt-480.png"><img src="https://raw.githubusercontent.com/yongkun/iobench/master/sample/iobench-rnd-iops-480.png" alt="sample/iobench-rnd-iops-480.png"></p>

<p><code>./plot_details.sh</code> will run <code>iobench</code> and plot response time or IOPS or throughput for each request on a timeline. This helps to understand the performance consistency during long time test.</p>

<p><img src="https://raw.githubusercontent.com/yongkun/iobench/master/sample/iobench-time-detail.png" alt="sample/iobench-time-detail.png"></p>

<h2>
<a name="why-another-micro-benchmark-tool" class="anchor" href="#why-another-micro-benchmark-tool"><span class="octicon octicon-link"></span></a>Why another micro benchmark tool?</h2>

<p>I want to understand the performance of disks by a very simple tool with easy customization. I developed this micro benchmark tool to understand the performance difference between hard disks and flash SSDs, which is very important for my papers and PhD dissertation. This tool also helps me validate benchmark results of other tools. The code here is a cleanup version. I hope it not only helps you understand the performance of storage systems, but also serves as an educational tool to show how to write a simple benchmark.</p>

<p>I benchmarked several SSDs from Mtron, Intel, and OCZ before. You can find the results here: 
[<a href="http://www.tkl.iis.u-tokyo.ac.jp/%7Eyongkun/paper/ieice-yongkun-wang-final.pdf">http://www.tkl.iis.u-tokyo.ac.jp/~yongkun/paper/ieice-yongkun-wang-final.pdf</a>]</p>

<h2>
<a name="contact" class="anchor" href="#contact"><span class="octicon octicon-link"></span></a>Contact</h2>

<p>yongkun at gmail.com</p>

<h2>
<a name="misc" class="anchor" href="#misc"><span class="octicon octicon-link"></span></a>Misc</h2>

<p>You can find many good stuff and microbenchmark tools here:
File and Storage System Benchmarking Portal <a href="http://fsbench.filesystems.org/">http://fsbench.filesystems.org/</a></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/yongkun">yongkun</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-53476203-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>