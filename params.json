{"name":"Iobench","tagline":"A microbenchmark for storage systems or devices such as hard disk and flash SSD.","body":"#iobench\r\n\r\n##A microbenchmark for storage systems or devices such as hard disk and flash SSD.\r\n\r\nFeatures:\r\n\r\n- Various IO sequences including sequential/random reads/writes, and mixed IOs.\r\n- Multi-threading to simulate multiple outstanding IOs.\r\n- Synchronous IO by O_SYNC and O_DIRECT to bypass OS or file system buffers.\r\n- Automatically generate figures for latency, throughput and IOPS.\r\n\r\nCheck the help to get more information.\r\n\r\n##Getting started\r\nJust type \r\n`make` or `./compile.sh` to build it, then run `./iobench`, it will print messages about read and write latency of your current disk.\r\n\r\nIt is tested on Linux and Mac OS X.\r\n\r\nNote that it is not recommended to use this tool on Mac OS X, because `O_DIRECT` and `lseek64` is not available on OS X. You may end up benchmarking the disk cache. It's only for development and test purpose.\r\n\r\nFor more details, please see the help page.\r\n\r\n```\r\n$ ./iobench -h\r\n\r\nNAME\r\n       iobench - microbenchmark for storage devices/systems\r\n\r\nSYNOPSIS\r\n       iobench  [ -d time ] [ -f filename ] [ -n count ] [ -H ]\r\n                [ -p size ] [ -o filename ] [ -P ] [ -r percent ]\r\n                [ -R time ] [ -s addr ] [ -S addr ] [ -t count ]\r\n                [ -w percent ]\r\n       iobench  -h\r\n\r\nDESCRIPTION\r\n       iobench is a microbenchmark for storage systems or devices\r\n       such as hard disk and flash SSD. It provides the following\r\n       features:\r\n           - Synchronous IO by O_SYNC and O_DIRECT to try to bypass\r\n             OS or file system buffer.\r\n           - Multi-threading to simulate multiple outstanding IOs.\r\n           - Various IO sequences including sequential/random\r\n             reads/writes, and mixed IOs with any R/W ratio.\r\n       It is recommended to tune your devices/systems for prefetching\r\n       or write-back cache with some tools like hdparm.\r\n\r\nOPTIONS\r\n   -d <time>       Duration of test of each thread in seconds. \r\n                   The longer the better, especially for SSDs.\r\n\r\n   -f <filename>   Filename for test. Can be device file like /dev/sda.\r\n                   This is a recommended way to test new drives.\r\n                   Make sure you have correct permissions.\r\n                   WARNING! All data include partition table will be\r\n                   overwritten! Cannot be recovered!\r\n\r\n   -n <count>      Send <number> of requests per thread. Program will\r\n                   terminate by -n or -d which happens first.\r\n\r\n   -H              Human friendly output.\r\n\r\n   -o <filename>   Output file to append. Default output to console.\r\n\r\n   -p <size>       Page size in sector (512B) for IO. This number\r\n                   is multiplied by 512. For example, -p 8 uses 4096\r\n                   as page size.\r\n\r\n   -P              Output the execution details of each request.\r\n\r\n   -r              Use random addresses. Random IO.\r\n\r\n   -R <time>       Rampup interval in seconds between threads.\r\n\r\n   -s <addr>       Initial file offset. Automatically aligned by 512.\r\n                   Default to 0.\r\n\r\n   -S <addr>       End offset. Automatically aligned by 512. Note\r\n                   that lseek64 is not defined on OSX, so the largest\r\n                   offset on Mac may be 2G even you specify larger\r\n                   value.\r\n                   If this value is larger than file length, reads\r\n                   or writes may happen on the hole of the file. Run\r\n                   'man lseek' to see the details. A safe way is to \r\n                   generate the file in advance using this tool or\r\n                   dd, then set the end offset smaller than the file\r\n                   length.\r\n                   For sequential read/write, file offset will be\r\n                   reset to initial address (-s) when file offset\r\n                   reaches this value.\r\n                   Within the valid address space, set this value the\r\n                   larger the better, which ensures large disk head\r\n                   movement in random access for hard disk, and might\r\n                   trigger more data movements and block erasures\r\n                   inside SSDs (it is highly depends on the\r\n                   implementation of FTL).\r\n                   Set this value to the capacity of disk when testing\r\n                   with device file.\r\n\r\n   -t <count>      Number of threads.\r\n\r\n   -w <percent>    Percent of write requests. 0-100. Default 50.\r\n\r\n```\r\n\r\nThere are some scripts to help you plot the figures with gnuplot. Gnuplot script is generated in output directory with data, can be easily customized to different figures.\r\n\r\n`./plot_figures.sh` will run `iobench` and plot the basic performance results into figures with throughput or IOPS.\r\n\r\n![iobench-seq-thrpt-480.png](sample/iobench-seq-thrpt-480.png)![iobench-rnd-iops-480.png](sample/iobench-rnd-iops-480.png)\r\n\r\n`./plot_details.sh` will run `iobench` and plot response time or IOPS or throughput for each request on a timeline. This helps to understand the performance consistency during long time test.\r\n\r\n![iobench-time-detail.png](sample/iobench-time-detail.png)\r\n\r\n##Why another micro benchmark tool?\r\nI want to understand the performance of disks by a very simple tool with easy customization. I developed this micro benchmark tool to understand the performance difference between hard disks and flash SSDs, which is very important for my papers and PhD dissertation. This tool also helps me validate benchmark results of other tools. The code here is a cleanup version. I hope it not only helps you understand the performance of storage systems, but also serves as an educational tool to show how to write a simple benchmark.\r\n\r\nI benchmarked several SSDs from Mtron, Intel, and OCZ before. You can find the results here: \r\n[http://www.tkl.iis.u-tokyo.ac.jp/~yongkun/paper/ieice-yongkun-wang-final.pdf]\r\n\r\n##Contact\r\nyongkun at gmail.com\r\n\r\n##Misc\r\n\r\nYou can find many good stuff and microbenchmark tools here:\r\nFile and Storage System Benchmarking Portal http://fsbench.filesystems.org/\r\n","google":"UA-53476203-2","note":"Don't delete this file! It's used internally to help with page regeneration."}